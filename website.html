<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIR QUALITY INDEX MONITORING</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #2196F3;
            --dark-color: #333;
            --light-color: #f4f4f4;
            --danger-color: #ff6b6b;
            --warning-color: #ffb142;
            --success-color: #1dd1a1;
            --unhealthy-color: #e67e22; /* New color for Unhealthy PM2.5 */
            --hazardous-color: #c0392b; /* New color for Hazardous PM2.5 */
            --very-unhealthy-color: #8e44ad; /* New color for Very Unhealthy PM2.5 */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f0f2f5;
            color: var(--dark-color);
            line-height: 1.6;
        }
        
        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            text-align: center;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .location {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 1rem;
            margin-top: 1rem;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .card {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        
        .card-title {
            font-size: 1.25rem;
            color: var(--primary-color);
        }
        
        .card-icon {
            font-size: 1.5rem;
            color: var(--secondary-color);
        }
        
        .reading {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin: 1.5rem 0;
        }
        
        .reading-unit {
            font-size: 1rem;
            color: #888;
        }
        
        .chart-container {
            height: 200px;
            margin-top: 1rem;
        }
        
        .status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
        }
        
        .status-good {
            background-color: var(--success-color);
        }
        
        .status-moderate {
            background-color: var(--warning-color);
        }
        
        .status-poor {
            background-color: var(--danger-color);
        }

        .status-unhealthy {
            background-color: var(--unhealthy-color);
        }

        .status-hazardous {
            background-color: var(--hazardous-color);
        }

        .status-very-unhealthy {
            background-color: var(--very-unhealthy-color);
        }
        
        .charts {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 2rem;
        }
        
        .chart-tabs {
            display: flex;
            border-bottom: 1px solid #eee;
            margin-bottom: 1rem;
        }
        
        .chart-tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .chart-tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 500;
        }
        
        .chart-panel {
            display: none;
            height: 400px;
        }
        
        .chart-panel.active {
            display: block;
        }
        
        .prediction {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-top: 2rem;
        }
        
        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        
        .prediction-title {
            font-size: 1.25rem;
            color: var(--primary-color);
        }
        
        .prediction-result {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .prediction-item {
            padding: 1rem;
            background-color: #f9f9f9;
            border-radius: 0.5rem;
            border-left: 4px solid var(--primary-color);
        }
        
        .prediction-label {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        
        .prediction-value {
            font-size: 1.25rem;
            font-weight: bold;
        }
        
        .status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        
        .footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            color: #888;
            font-size: 0.875rem;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background-color: rgba(255, 107, 107, 0.1);
            border-left: 4px solid var(--danger-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
        }
        
        .refresh-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .refresh-btn:hover {
            background-color: #388e3c;
        }

        #data-table {
            width: 100%;
            margin-top: 2rem;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        
        #data-table th, #data-table td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        #data-table th {
            background-color: #f4f4f4;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        #data-table tr:last-child td {
            border-bottom: none;
        }
        
        #data-table tr:hover {
            background-color: #f9f9f9;
        }
        
        .download-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .download-btn:hover {
            background-color: #0b7dda;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AIR QUALITY INDEX MONITORING</h1>
            <p>Real-time environmental data monitoring and analysis</p>
            <div class="location">
                <span id="location-icon">üìç</span>
                <span id="current-location">Loading location...</span>
            </div>
        </header>
        
        <div class="dashboard">
            <div class="card" id="temperature-card">
                <div class="card-header">
                    <h2 class="card-title">Temperature</h2>
                    <span class="card-icon">üå°</span>
                </div>
                <div class="reading" id="temperature-reading">
                    -- <span class="reading-unit">¬∞C</span>
                </div>
                <div class="chart-container">
                    <canvas id="temperature-chart"></canvas>
                </div>
            </div>
            
            <div class="card" id="humidity-card">
                <div class="card-header">
                    <h2 class="card-title">Humidity</h2>
                    <span class="card-icon">üíß</span>
                </div>
                <div class="reading" id="humidity-reading">
                    -- <span class="reading-unit">%</span>
                </div>
                <div class="chart-container">
                    <canvas id="humidity-chart"></canvas>
                </div>
            </div>
            
            <div class="card" id="gas-card">
                <div class="card-header">
                    <h2 class="card-title">Gas Level</h2>
                    <span class="card-icon">üå´</span>
                </div>
                <div class="reading" id="gas-reading">
                    -- <span class="reading-unit">ppm</span>
                </div>
                <div>
                    <span class="status" id="gas-status">Unknown</span>
                </div>
                <div class="chart-container">
                    <canvas id="gas-chart"></canvas>
                </div>
            </div>

            <div class="card" id="pm25-card">
                <div class="card-header">
                    <h2 class="card-title">PM2.5 (Dust Sensitivity)</h2>
                    <span class="card-icon">üí®</span>
                </div>
                <div class="reading" id="pm25-reading">
                    -- <span class="reading-unit">¬µg/m¬≥</span>
                </div>
                <div>
                    <span class="status" id="pm25-status">Unknown</span>
                </div>
                <div class="chart-container">
                    <canvas id="pm25-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart-tabs">
                <div class="chart-tab active" data-tab="all-parameters">All Parameters</div>
                <div class="chart-tab" data-tab="gas-details">Gas Details</div>
                <div class="chart-tab" data-tab="correlation">Correlation</div>
            </div>
            
            <div class="chart-panel active" id="all-parameters-panel">
                <canvas id="all-parameters-chart"></canvas>
            </div>
            
            <div class="chart-panel" id="gas-details-panel">
                <canvas id="gas-details-chart"></canvas>
            </div>
            
            <div class="chart-panel" id="correlation-panel">
                <canvas id="correlation-chart"></canvas>
            </div>
        </div>
        
        <div class="prediction">
            <div class="prediction-header">
                <h2 class="prediction-title">AI Prediction Results</h2>
                <button class="refresh-btn" id="refresh-prediction">
                    Refresh Prediction
                </button>
            </div>
            
            <div class="prediction-result">
                <div class="prediction-item">
                    <div class="prediction-label">Predicted Gas Level</div>
                    <div class="prediction-value" id="predicted-gas">--</div>
                </div>
                
                <div class="prediction-item">
                    <div class="prediction-label">Pollutant Type (Gas)</div>
                    <div class="prediction-value" id="pollutant-type">--</div>
                </div>
                
                <div class="prediction-item">
                    <div class="prediction-label">Overall Air Quality</div>
                    <div class="prediction-value" id="overall-air-quality">--</div>
                </div>

                <div class="prediction-item">
                    <div class="prediction-label">PM2.5 Quality</div>
                    <div class="prediction-value" id="pm25-prediction-quality">--</div>
                </div>
                
                <div class="prediction-item">
                    <div class="prediction-label">Confidence Score</div>
                    <div class="prediction-value" id="confidence-score">--</div>
                </div>
            </div>
        </div>
        
        <div class="data-section">
            <h2>Historical Data</h2>
            <div id="table-container">
                <table id="data-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Temperature (¬∞C)</th>
                            <th>Humidity (%)</th>
                            <th>Gas (ppm)</th>
                            <th>PM2.5 (¬µg/m¬≥)</th> <th>Pollutant Type (Gas)</th>
                            <th>PM2.5 Quality</th> </tr>
                    </thead>
                    <tbody id="data-table-body">
                        <tr>
                            <td colspan="7" class="loading">Loading data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <button class="download-btn" id="download-csv">
                Download CSV Data
            </button>
        </div>
        
        <footer class="footer">
            <p>Air Quality Index Monitoring System ¬© 2025</p>
        </footer>
    </div>

    <script>
        const CHANNEL_ID = '2918627'; // Replace with your ThingSpeak channel ID
        const API_KEY = '3TW5RRLGEWUWSPES'; // Replace with your ThingSpeak read API key
        const MAX_POINTS = 10; // Number of points to show in individual charts
        let allData = []; // Stores all fetched data for historical views
        let charts = {}; // Object to hold all Chart.js instances
        let locationData = {}; // Stores geolocation data

        // Backend URL placeholder. IMPORTANT: Replace this with your deployed Node.js backend URL
        // If you are NOT using a Node.js backend and fetching directly from ThingSpeak for everything,
        // you might remove prediction features or implement them client-side.
        // For GitHub Pages, localhost will not work.
        const BACKEND_API_URL = 'http://localhost:3000'; // *** CHANGE THIS TO YOUR DEPLOYED BACKEND URL ***

        class AirQualityModel {
            constructor(data) {
                this.xgbCoefficients = {
                    temperature: 0.5,
                    humidity: 0.3,
                    intercept: 10
                };
                this.scalers = { // Used for standardization, updated from historical data
                    temperature: { mean: 25, std: 5 },
                    humidity: { mean: 60, std: 15 },
                    gas: { mean: 300, std: 150 }
                };
                if (data && data.length > 0) {
                    this.updateScalers(data);
                }
            }

            // Updates mean and standard deviation for scaling based on historical data
            updateScalers(data) {
                const temps = data.map(d => d.temperature).filter(v => !isNaN(v));
                const hums = data.map(d => d.humidity).filter(v => !isNaN(v));
                const gases = data.map(d => d.gas).filter(v => !isNaN(v));
                
                if (temps.length > 0) {
                    this.scalers.temperature.mean = temps.reduce((a, b) => a + b, 0) / temps.length;
                    this.scalers.temperature.std = Math.sqrt(
                        temps.reduce((a, b) => a + Math.pow(b - this.scalers.temperature.mean, 2), 0) / temps.length
                    ) || 1; // Prevent division by zero
                }
                if (hums.length > 0) {
                    this.scalers.humidity.mean = hums.reduce((a, b) => a + b, 0) / hums.length;
                    this.scalers.humidity.std = Math.sqrt(
                        hums.reduce((a, b) => a + Math.pow(b - this.scalers.humidity.mean, 2), 0) / hums.length
                    ) || 1;
                }
                if (gases.length > 0) {
                    this.scalers.gas.mean = gases.reduce((a, b) => a + b, 0) / gases.length;
                    this.scalers.gas.std = Math.sqrt(
                        gases.reduce((a, b) => a + Math.pow(b - this.scalers.gas.mean, 2), 0) / gases.length
                    ) || 1;
                }
            }

            // Standardizes a value using the calculated scaler properties
            standardize(value, feature) {
                return (value - this.scalers[feature].mean) / this.scalers[feature].std;
            }

            // Unstandardizes a value back to its original scale
            unstandardize(value, feature) {
                return value * this.scalers[feature].std + this.scalers[feature].mean;
            }

            // Predicts gas level based on temperature and humidity using hardcoded coefficients
            // PM2.5 is NOT used in the prediction of gas level as per requirement.
            predict(temperature, humidity) {
                if (isNaN(temperature) || isNaN(humidity)) {
                    return 0;
                }
                const tempStd = this.standardize(temperature, 'temperature');
                const humidityStd = this.standardize(humidity, 'humidity');
                const gasStd =
                    this.xgbCoefficients.temperature * tempStd +
                    this.xgbCoefficients.humidity * humidityStd +
                    this.xgbCoefficients.intercept;
                return Math.max(0, this.unstandardize(gasStd, 'gas')); // Gas cannot be negative
            }

            // Classifies gas concentration into types (based on custom ranges)
            detectGasType(concentration) {
                if (concentration < 12) {
                    return "Clean Air";
                } else if (concentration < 20) {
                    return "CO2 (Carbon Dioxide)";
                } else if (concentration < 30) {
                    return "NO2 (Nitrogen Dioxide)";
                } else if (concentration < 45) {
                    return "NH3 (Ammonia)";
                } else if (concentration < 60) {
                    return "CO (Carbon Monoxide)";
                } else {
                    return "Mixed Pollutants";
                }
            }

            // Calculates a confidence score for the prediction
            calculateConfidence(temperature, humidity) {
                if (isNaN(temperature) || isNaN(humidity)) {
                    return "50.0%"; // Default low confidence if inputs are invalid
                }
                const tempDist = Math.abs(this.standardize(temperature, 'temperature'));
                const humDist = Math.abs(this.standardize(humidity, 'humidity'));
                let confidence = 100 - (tempDist + humDist) * 10; // Simple inverse relationship with deviation
                return Math.max(Math.min(confidence, 100), 50).toFixed(1) + '%'; // Clamp between 50% and 100%
            }

            // Classifies PM2.5 value into air quality categories (based on US EPA AQI breakpoints)
            getPm25Quality(pm25Value) {
                if (isNaN(pm25Value) || pm25Value < 0) return { label: "Unknown", class: "" };
                
                if (pm25Value <= 12.0) {
                    return { label: "Good", class: "status-good" };
                } else if (pm25Value <= 35.4) {
                    return { label: "Moderate", class: "status-moderate" };
                } else if (pm25Value <= 55.4) {
                    return { label: "Unhealthy for Sensitive", class: "status-poor" }; 
                } else if (pm25Value <= 150.4) {
                    return { label: "Unhealthy", class: "status-unhealthy" };
                } else if (pm25Value <= 250.4) {
                    return { label: "Very Unhealthy", class: "status-very-unhealthy" }; 
                } else if (pm25Value <= 350.4) {
                    return { label: "Hazardous", class: "status-hazardous" };
                } else {
                    return { label: "Beyond Index", class: "status-hazardous" };
                }
            }

            // Determines overall air quality by considering both gas level (predicted) and PM2.5 level
            // Prioritizes the "worse" quality if both are present.
            getOverallAirQuality(gasLevel, pm25Level = null) {
                let overallQuality = { label: "Good", class: "status-good" };

                // Evaluate Gas Level based on its custom ranges
                if (gasLevel < 15) {
                    // Good based on gas
                } else if (gasLevel < 50) {
                    overallQuality = { label: "Moderate", class: "status-moderate" };
                } else {
                    overallQuality = { label: "Poor", class: "status-poor" };
                }

                // If PM2.5 data is available, evaluate it and potentially worsen the overall quality
                if (pm25Level !== null && !isNaN(pm25Level)) {
                    const pm25Quality = this.getPm25Quality(pm25Level);
                    
                    // Define a hierarchy of air quality levels (lower index means better quality)
                    const qualityHierarchy = {
                        "Good": 0,
                        "Moderate": 1,
                        "Unhealthy for Sensitive": 2,
                        "Poor": 2, // Mapping 'Poor' gas quality to the same level as 'Unhealthy for Sensitive' PM2.5 for comparison
                        "Unhealthy": 3,
                        "Very Unhealthy": 4,
                        "Hazardous": 5,
                        "Beyond Index": 6
                    };

                    const currentOverallLevel = qualityHierarchy[overallQuality.label] || 0;
                    const pm25LevelIndex = qualityHierarchy[pm25Quality.label] || 0;

                    // If PM2.5 quality is worse than the current overall quality, update overall
                    if (pm25LevelIndex > currentOverallLevel) {
                        overallQuality = pm25Quality;
                    }
                }
                return overallQuality;
            }
        }

        let model = new AirQualityModel(); // Initialize the model globally

        // Function to initialize all Chart.js instances
        function initCharts() {
            // Temperature Chart
            charts.temperature = new Chart(
                document.getElementById('temperature-chart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Temperature',
                            data: [],
                            borderColor: '#FF6384',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        scales: {
                            y: { beginAtZero: false }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false,
                        animation: { duration: 500 }
                    }
                }
            );

            // Humidity Chart
            charts.humidity = new Chart(
                document.getElementById('humidity-chart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Humidity',
                            data: [],
                            borderColor: '#36A2EB',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        scales: {
                            y: { beginAtZero: false }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false,
                        animation: { duration: 500 }
                    }
                }
            );

            // Gas Chart
            charts.gas = new Chart(
                document.getElementById('gas-chart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Gas',
                            data: [],
                            borderColor: '#4BC0C0',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        scales: {
                            y: { beginAtZero: true }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false,
                        animation: { duration: 500 }
                    }
                }
            );

            // PM2.5 Chart
            charts.pm25 = new Chart(
                document.getElementById('pm25-chart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'PM2.5',
                            data: [],
                            borderColor: '#FFCE56', // A distinct color for PM2.5
                            backgroundColor: 'rgba(255, 206, 86, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        scales: {
                            y: { beginAtZero: true }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false,
                        animation: { duration: 500 }
                    }
                }
            );

            // All Parameters Chart
            charts.allParameters = new Chart(
                document.getElementById('all-parameters-chart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Temperature (¬∞C)',
                                data: [],
                                borderColor: '#FF6384',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                borderWidth: 2,
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Humidity (%)',
                                data: [],
                                borderColor: '#36A2EB',
                                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                borderWidth: 2,
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Gas (ppm)',
                                data: [],
                                borderColor: '#4BC0C0',
                                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                borderWidth: 2,
                                tension: 0.4,
                                yAxisID: 'y1'
                            },
                            {
                                label: 'PM2.5 (¬µg/m¬≥)', 
                                data: [],
                                borderColor: '#FFCE56',
                                backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                borderWidth: 2,
                                tension: 0.4,
                                yAxisID: 'y1' 
                            }
                        ]
                    },
                    options: {
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Temp (¬∞C) / Humidity (%)'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Gas (ppm) / PM2.5 (¬µg/m¬≥)'
                                },
                                grid: {
                                    drawOnChartArea: false
                                }
                            }
                        },
                        plugins: {
                            legend: { position: 'top' }
                        },
                        maintainAspectRatio: false,
                        responsive: true
                    }
                }
            );

            // Gas Details Chart (Bar Chart)
            charts.gasDetails = new Chart(
                document.getElementById('gas-details-chart'),
                {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Gas Level (ppm)',
                            data: [],
                            backgroundColor: '#4BC0C0',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Gas Concentration (ppm)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false,
                        responsive: true
                    }
                }
            );

            // Correlation Chart (Scatter Plot)
            charts.correlation = new Chart(
                document.getElementById('correlation-chart'),
                {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Temperature vs Gas',
                            data: [],
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            pointRadius: 5
                        }, {
                            label: 'Humidity vs Gas',
                            data: [],
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            pointRadius: 5
                        }]
                    },
                    options: {
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Temperature (¬∞C) / Humidity (%)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Gas Level (ppm)'
                                }
                            }
                        },
                        plugins: {
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.datasetIndex === 0) { // Temperature vs Gas
                                            label += (${context.parsed.x.toFixed(1)}¬∞C, ${context.parsed.y.toFixed(1)} ppm);
                                        } else { // Humidity vs Gas
                                            label += (${context.parsed.x.toFixed(1)}%, ${context.parsed.y.toFixed(1)} ppm);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        maintainAspectRatio: false,
                        responsive: true
                    }
                }
            );
        } // CLOSING BRACE FOR initCharts() - This is where the syntax error likely was before.

        // Function to fetch data from ThingSpeak API
        async function fetchData(retryCount = 3) {
            console.log(Attempting to fetch data from ThingSpeak (Attempt ${4 - retryCount}/3));
            try {
                // Fetches field1 (temperature), field2 (humidity), field3 (gas), field4 (PM2.5)
                const response = await fetch(https://api.thingspeak.com/channels/${CHANNEL_ID}/feeds.json?api_key=${API_KEY}&results=50, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                if (!response.ok) {
                    throw new Error(HTTP error! Status: ${response.status} - ${response.statusText});
                }
                const data = await response.json();
                console.log('ThingSpeak API response:', data);
                if (!data || !data.feeds || !Array.isArray(data.feeds)) {
                    throw new Error('Invalid data format: feeds array is missing or malformed');
                }
                if (data.feeds.length === 0) {
                    console.warn('No data feeds available from ThingSpeak. Dashboard will show empty.');
                    // Optionally, you could show a "No Data Available" message on the UI
                    return []; 
                }
                processData(data.feeds);
                storeDataAsCSV(data.feeds);
                return data.feeds;
            } catch (error) {
                console.error('Error fetching ThingSpeak data:', error.message);
                if (retryCount > 1) {
                    console.log(Retrying... (${retryCount - 1} attempts left));
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
                    return fetchData(retryCount - 1);
                }
                showError(Failed to fetch data from ThingSpeak: ${error.message}. Please check your API key and channel ID.);
                return [];
            }
        }

        // Processes raw data from ThingSpeak into a usable format
        function processData(feeds) {
            if (!feeds || feeds.length === 0) {
                showError('No data feeds to process.');
                return;
            }
            allData = feeds.map(feed => {
                const timestamp = new Date(feed.created_at);
                const temperature = parseFloat(feed.field1);
                const humidity = parseFloat(feed.field2);
                const gas = parseFloat(feed.field3);
                const pm25 = parseFloat(feed.field4); // Assuming field4 is PM2.5 (Dust Sensitivity)

                // Filter out any entries with invalid (NaN) sensor readings
                if (isNaN(temperature) || isNaN(humidity) || isNaN(gas) || isNaN(pm25)) {
                    return null; // Return null for invalid entries, will be filtered out later
                }

                const gasType = model.detectGasType(gas);
                const pm25Quality = model.getPm25Quality(pm25);
                return {
                    timestamp,
                    formattedTime: formatTime(timestamp),
                    temperature,
                    humidity,
                    gas,
                    pm25,
                    gasType,
                    pm25QualityLabel: pm25Quality.label,
                    pm25QualityClass: pm25Quality.class
                };
            }).filter(item => item !== null); // Filter out null entries (invalid data)

            console.log('Processed data:', allData);
            if (allData.length > 0) {
                model = new AirQualityModel(allData); // Re-initialize model with potentially updated scalers based on new data
                console.log('Updated model scalers:', model.scalers);
                updateDashboard(allData[allData.length - 1]); // Update dashboard with latest reading
                updateCharts(allData); // Update all charts
                updateTable(allData); // Update historical data table
                runPrediction(allData[allData.length - 1]); // Run prediction with latest data
            } else {
                showError('No valid data points available for processing after filtering.');
            }
        }

        // Updates the main dashboard cards with the latest sensor readings
        function updateDashboard(latestData) {
            document.getElementById('temperature-reading').innerHTML = 
                ${latestData.temperature.toFixed(1)} <span class="reading-unit">¬∞C</span>;
            document.getElementById('humidity-reading').innerHTML = 
                ${latestData.humidity.toFixed(1)} <span class="reading-unit">%</span>;
            document.getElementById('gas-reading').innerHTML = 
                ${latestData.gas.toFixed(1)} <span class="reading-unit">ppm</span>;
            
            // Gas status (individual status for the card based on gas levels)
            const gasStatus = model.getOverallAirQuality(latestData.gas); // Using overall for consistency, but you can revert to simple if preferred
            const statusElement = document.getElementById('gas-status');
            statusElement.textContent = gasStatus.label;
            statusElement.className = status ${gasStatus.class};

            document.getElementById('pm25-reading').innerHTML = 
                ${latestData.pm25.toFixed(1)} <span class="reading-unit">¬µg/m¬≥</span>;
            // PM2.5 status (individual status for the card based on PM2.5 levels)
            const pm25Status = model.getPm25Quality(latestData.pm25);
            const pm25StatusElement = document.getElementById('pm25-status');
            pm25StatusElement.textContent = pm25Status.label;
            pm25StatusElement.className = status ${pm25Status.class};
        }

        // Updates all Chart.js instances with new data
        function updateCharts(data) {
            const recentData = data.slice(-MAX_POINTS); // Data for smaller dashboard charts
            const labels = recentData.map(d => d.formattedTime);

            charts.temperature.data.labels = labels;
            charts.temperature.data.datasets[0].data = recentData.map(d => d.temperature);
            charts.temperature.update();

            charts.humidity.data.labels = labels;
            charts.humidity.data.datasets[0].data = recentData.map(d => d.humidity);
            charts.humidity.update();

            charts.gas.data.labels = labels;
            charts.gas.data.datasets[0].data = recentData.map(d => d.gas);
            charts.gas.update();

            charts.pm25.data.labels = labels;
            charts.pm25.data.datasets[0].data = recentData.map(d => d.pm25);
            charts.pm25.update();

            // All Parameters Chart uses all available data
            charts.allParameters.data.labels = data.map(d => d.formattedTime);
            charts.allParameters.data.datasets[0].data = data.map(d => d.temperature);
            charts.allParameters.data.datasets[1].data = data.map(d => d.humidity);
            charts.allParameters.data.datasets[2].data = data.map(d => d.gas);
            charts.allParameters.data.datasets[3].data = data.map(d => d.pm25); 
            charts.allParameters.update();

            charts.gasDetails.data.labels = data.map(d => d.formattedTime);
            charts.gasDetails.data.datasets[0].data = data.map(d => d.gas);
            charts.gasDetails.update();

            const tempGasCorrelation = data.map(d => ({ x: d.temperature, y: d.gas }));
            const humGasCorrelation = data.map(d => ({ x: d.humidity, y: d.gas }));
            charts.correlation.data.datasets[0].data = tempGasCorrelation;
            charts.correlation.data.datasets[1].data = humGasCorrelation;
            charts.correlation.update();
        }

        // Updates the historical data table
        function updateTable(data) {
            const tableBody = document.getElementById('data-table-body');
            tableBody.innerHTML = ''; // Clear previous rows
            const sortedData = [...data].sort((a, b) => b.timestamp - a.timestamp); // Sort by latest first
            const recentData = sortedData.slice(0, 20); // Show only the 20 most recent entries

            if (recentData.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7">No data available</td></tr>';
                return;
            }

            recentData.forEach(item => {
                const formattedDate = item.timestamp.toLocaleString();
                const gasType = item.gasType; 
                const pm25Status = model.getPm25Quality(item.pm25); 

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${item.temperature.toFixed(1)} ¬∞C</td>
                    <td>${item.humidity.toFixed(1)} %</td>
                    <td>${item.gas.toFixed(1)} ppm</td>
                    <td>${item.pm25.toFixed(1)} ¬µg/m¬≥</td>
                    <td>
                        <span class="status-indicator" style="background-color: ${getColorForGasType(gasType)}"></span>
                        ${gasType}
                    </td>
                    <td>
                        <span class="status-indicator" style="background-color: ${getComputedStyle(document.documentElement).getPropertyValue(--${pm25Status.class.replace('status-', '')}-color).trim()}"></span>
                        ${pm25Status.label}
                    </td>
                `;
                tableBody.appendChild(row);
            });
        }

        // Helper to get color for gas type status indicator
        function getColorForGasType(gasType) {
            switch(gasType) {
                case "Clean Air": return '#1dd1a1';
                case "CO2 (Carbon Dioxide)": return '#a4b0be'; // Greyish for CO2
                case "CO (Carbon Monoxide)": return '#ffb142';
                case "NO2 (Nitrogen Dioxide)": return '#ff9f43';
                case "NH3 (Ammonia)": return '#ee5253';
                case "Mixed Pollutants": return '#ff6b6b';
                case "Hazardous Air": return '#b71540';
                default: return '#777'; // Default grey
            }
        }

        // Runs the prediction using the backend API and updates the prediction results
        async function runPrediction(latestData) {
            const temperature = latestData.temperature;
            const humidity = latestData.humidity;
            const pm25 = latestData.pm25; 

            // Make an API call to your Node.js backend's prediction endpoint
            try {
                const response = await fetch(${BACKEND_API_URL}/api/predict?temperature=${temperature}&humidity=${humidity}&pm25=${pm25});
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(HTTP error! Status: ${response.status} - ${errorText});
                }
                const data = await response.json();
                console.log('Prediction API response:', data);

                if (data.success && data.prediction) {
                    document.getElementById('predicted-gas').textContent = ${data.prediction.gasLevel.toFixed(1)} ppm;
                    document.getElementById('pollutant-type').textContent = data.prediction.gasType;
                    
                    // Overall Air Quality from backend
                    const overallQualityLabel = data.prediction.overallAirQuality;
                    const overallQualityClass = model.getOverallAirQuality(data.prediction.gasLevel, pm25).class; // Re-use frontend logic for class
                    document.getElementById('overall-air-quality').innerHTML = 
                        <span class="status ${overallQualityClass}">${overallQualityLabel}</span>;

                    // PM2.5 Quality from backend
                    const pm25QualityLabel = data.prediction.pm25Quality;
                    const pm25QualityClass = model.getPm25Quality(pm25).class; // Re-use frontend logic for class
                    document.getElementById('pm25-prediction-quality').innerHTML = 
                        <span class="status ${pm25QualityClass}">${pm25QualityLabel}</span>;
                    
                    document.getElementById('confidence-score').textContent = ${data.prediction.confidence}%;
                } else {
                    showError(Prediction failed: ${data.error || 'Unknown error'});
                }
            } catch (error) {
                console.error('Error fetching prediction:', error);
                showError(Failed to get prediction from backend: ${error.message}. Is your backend running and accessible at ${BACKEND_API_URL}?);
                // Fallback to client-side prediction if backend fails, though less accurate without ML model
                const predictedGas = model.predict(temperature, humidity);
                const pollutantType = model.detectGasType(predictedGas);
                const overallAirQuality = model.getOverallAirQuality(predictedGas, pm25);
                const pm25Quality = model.getPm25Quality(pm25);
                const confidenceScore = model.calculateConfidence(temperature, humidity);

                document.getElementById('predicted-gas').textContent = ${predictedGas.toFixed(1)} ppm (Client-side Fallback);
                document.getElementById('pollutant-type').textContent = pollutantType;
                document.getElementById('overall-air-quality').innerHTML = 
                    <span class="status ${overallAirQuality.class}">${overallAirQuality.label}</span> (Client-side Fallback);
                document.getElementById('pm25-prediction-quality').innerHTML = 
                    <span class="status ${pm25Quality.class}">${pm25Quality.label}</span> (Client-side Fallback);
                document.getElementById('confidence-score').textContent = confidenceScore;
            }
        }

        // Stores processed data in CSV format in LocalStorage
        function storeDataAsCSV(feeds) {
            const processedData = feeds.map(feed => {
                const timestamp = new Date(feed.created_at);
                const temperature = parseFloat(feed.field1) || 0;
                const humidity = parseFloat(feed.field2) || 0;
                const gas = parseFloat(feed.field3) || 0;
                const pm25 = parseFloat(feed.field4) || 0; // Assuming field4 is PM2.5
                const gasType = model.detectGasType(gas);
                const pm25Quality = model.getPm25Quality(pm25).label;
                return {
                    timestamp: timestamp.toISOString(),
                    temperature,
                    humidity,
                    gas,
                    pm25,
                    gas_type: gasType,
                    pm25_quality: pm25Quality
                };
            }).filter(item => !isNaN(item.temperature) && !isNaN(item.humidity) && !isNaN(item.gas) && !isNaN(item.pm25));
            const csvContent = Papa.unparse(processedData);
            localStorage.setItem('airQualityData', csvContent);
            return csvContent;
        }

        // Triggers download of the stored CSV data
        function downloadCSV() {
            const csvContent = localStorage.getItem('airQualityData') || '';
            if (!csvContent) {
                alert('No data available to download.');
                return;
            }
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'air_quality_data.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Formats Date objects to display only time (HH:MM)
        function formatTime(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Displays an error message prominently on the UI
        function showError(message) {
            console.warn('Error displayed:', message);
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            const container = document.querySelector('.container');
            // Insert error message at the top of the container
            if (container.firstChild) {
                container.insertBefore(errorDiv, container.firstChild);
            } else {
                container.appendChild(errorDiv);
            }
            // Remove error message after 10 seconds
            setTimeout(() => {
                errorDiv.remove();
            }, 10000);
        }

        // Fetches current geolocation and reverse geocodes it to a city/state name
        function getCurrentLocation() {
            // Geolocation requires a secure context (HTTPS or localhost)
            if (!window.isSecureContext) {
                showError('Geolocation requires a secure context (HTTPS or localhost). Location feature disabled.');
                document.getElementById('current-location').textContent = 'Secure context required';
                return;
            }
            if (!navigator.geolocation) {
                showError('Geolocation is not supported by this browser. Location feature disabled.');
                document.getElementById('current-location').textContent = 'Geolocation not supported';
                return;
            }

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    console.log(Geolocation success: Latitude=${lat}, Longitude=${lon});
                    try {
                        // Using Nominatim for reverse geocoding
                        const response = await fetch(https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}, {
                            headers: { 'User-Agent': 'AirQualityMonitor/1.0' } // Required by Nominatim
                        });
                        if (!response.ok) {
                            throw new Error(Nominatim HTTP error! Status: ${response.status});
                        }
                        const data = await response.json();
                        console.log('Nominatim API response:', data);
                        let location = 'Unknown Location';
                        if (data && data.address) {
                            location = data.address.city || data.address.town || data.address.village || 'Unknown City';
                            if (data.address.state) {
                                location += , ${data.address.state};
                            }
                        }
                        document.getElementById('current-location').textContent = location;
                        locationData = { lat, lon, location };
                    } catch (error) {
                        console.error('Error getting location name:', error.message);
                        showError(Failed to fetch location name: ${error.message}. Displaying coordinates.);
                        document.getElementById('current-location').textContent = ${lat.toFixed(4)}, ${lon.toFixed(4)};
                    }
                },
                (error) => {
                    console.error('Geolocation error:', error.message);
                    let errorMessage = 'Location unavailable';
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'Location access denied by user.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'Location request timed out.';
                            break;
                    }
                    showError(Geolocation failed: ${errorMessage}. Location feature disabled.);
                    document.getElementById('current-location').textContent = errorMessage;
                },
                {
                    timeout: 10000, // 10 seconds
                    maximumAge: 60000 // Cache location for 1 minute
                }
            );
        }

        // Initializes chart tab functionality
        function initTabs() {
            const tabs = document.querySelectorAll('.chart-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelectorAll('.chart-panel').forEach(panel => {
                        panel.classList.remove('active');
                    });
                    const panelId = ${tab.dataset.tab}-panel;
                    document.getElementById(panelId).classList.add('active');
                    // Ensure charts resize correctly when their panel becomes active
                    Object.values(charts).forEach(chart => chart.resize());
                });
            });
        }

        // Main initialization function, called when the DOM is fully loaded
        async function init() {
            // Check for secure context as many modern APIs require it
            if (!window.isSecureContext) {
                showError('This application requires a secure context (HTTPS or localhost) for API and geolocation features. Some features may not work.');
            }
            
            initCharts(); // Initialize all Chart.js instances
            initTabs(); // Set up tab switching logic
            getCurrentLocation(); // Get user's current location

            // Fetch initial data and set up periodic updates
            await fetchData(); // Initial data fetch
            setInterval(fetchData, 30000); // Fetch data every 30 seconds

            // Event listener for refreshing prediction
            document.getElementById('refresh-prediction').addEventListener('click', () => {
                if (allData.length > 0) {
                    runPrediction(allData[allData.length - 1]);
                } else {
                    showError('No data available for prediction. Fetching new data...');
                    fetchData(); // Try to fetch data if none is available
                }
            });

            // Event listener for downloading CSV
            document.getElementById('download-csv').addEventListener('click', downloadCSV);
        }

        // Add event listener to run init() when the DOM content is fully loaded
        document.addEventListener('DOMContentLoaded', init);

        // --- Backend Simulation Class (for reference, not directly used by GitHub Pages) ---
        // This class was part of the local Node.js backend logic and ML script explanation.
        // It's included here for completeness of the original full context, but its methods
        // are not executed by the frontend directly when hosted on GitHub Pages.
        class BackendSimulation {
            constructor() {
                this.dataFile = 'air_quality_data.csv';
                // In a real backend, this might trigger ML model retraining periodically
                // setInterval(() => this.processDataForML(), 60000); 
            }

            processDataForML() {
                console.log("Backend: Processing data for ML model (simulated)");
                // In a real setup, this would load data, train model, etc.
                console.log("Backend: ML processing complete (simulated)");
            }

            getHistoricalAnalysis() {
                const analysis = {
                    averageTemperature: 0,
                    averageHumidity: 0,
                    averageGas: 0,
                    averagePm25: 0, 
                    dominantGasType: '',
                    dominantPm25Quality: '', 
                    recommendations: []
                };
                if (allData.length > 0) {
                    analysis.averageTemperature = allData.reduce((sum, item) => sum + item.temperature, 0) / allData.length;
                    analysis.averageHumidity = allData.reduce((sum, item) => sum + item.humidity, 0) / allData.length;
                    analysis.averageGas = allData.reduce((sum, item) => sum + item.gas, 0) / allData.length;
                    analysis.averagePm25 = allData.reduce((sum, item) => sum + item.pm25, 0) / allData.length;

                    const gasTypeCounts = {};
                    allData.forEach(item => {
                        gasTypeCounts[item.gasType] = (gasTypeCounts[item.gasType] || 0) + 1;
                    });
                    let maxGasCount = 0;
                    for (const gasType in gasTypeCounts) {
                        if (gasTypeCounts[gasType] > maxGasCount) {
                            maxGasCount = gasTypeCounts[gasType];
                            analysis.dominantGasType = gasType;
                        }
                    }

                    const pm25QualityCounts = {};
                    allData.forEach(item => {
                        pm25QualityCounts[item.pm25QualityLabel] = (pm25QualityCounts[item.pm25QualityLabel] || 0) + 1;
                    });
                    let maxPm25Count = 0;
                    for (const quality in pm25QualityCounts) {
                        if (pm25QualityCounts[quality] > maxPm25Count) {
                            maxPm25Count = pm25QualityCounts[quality];
                            analysis.dominantPm25Quality = quality;
                        }
                    }

                    const overallQuality = model.getOverallAirQuality(analysis.averageGas, analysis.averagePm25);

                    if (overallQuality.label === "Good") {
                        analysis.recommendations.push("Air quality is generally good. No specific actions needed.");
                    } else if (overallQuality.label === "Moderate") {
                        analysis.recommendations.push("Air quality is moderate. Sensitive individuals should consider reducing prolonged or heavy exertion outdoors.");
                        analysis.recommendations.push("Consider improving ventilation in the monitored area.");
                    } else if (overallQuality.label === "Unhealthy for Sensitive") {
                         analysis.recommendations.push("Air quality is unhealthy for sensitive groups. People with heart or lung disease, older adults, and children should reduce prolonged or heavy exertion.");
                         analysis.recommendations.push("Monitor CO levels and ensure CO detectors are working if gas levels are also elevated.");
                    } else if (overallQuality.label === "Unhealthy") {
                        analysis.recommendations.push("Air quality is unhealthy. Everyone may begin to experience health effects; sensitive groups may experience more serious health effects.");
                        analysis.recommendations.push("Limit outdoor activity and consider wearing masks if outdoors is unavoidable.");
                        analysis.recommendations.push("Check for potential NO2 or NH3 sources if gas levels are significant.");
                    } else if (overallQuality.label === "Hazardous" || overallQuality.label === "Very Unhealthy" || overallQuality.label === "Beyond Index") {
                        analysis.recommendations.push("HAZARDOUS AIR QUALITY! Immediate evacuation recommended if possible.");
                        analysis.recommendations.push("Stay indoors, close windows and doors, and use air purifiers if available.");
                        analysis.recommendations.push("Contact environmental authorities for further guidance.");
                    }
                }
                return analysis;
            }
        }

        const backendSimulationInstance = new BackendSimulation(); // Renamed to avoid potential global conflict
    </script>
</body>
</html>
